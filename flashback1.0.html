<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Custom Flashback Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }

        .container-flashback {
            max-width: 1024px;
            margin: auto;
        }

        .event-card {
            cursor: grab;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            touch-action: none; /* Prevents default browser actions on touch */
        }

        .event-card:active {
            cursor: grabbing;
        }

        .event-card.dragging {
            opacity: 0.5;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            transform: scale(1.05);
        }

        .timeline-slot {
            transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;
        }

        .timeline-slot.dragover {
            background-color: #d1d5db; /* A bit darker gray */
            border-color: #6b7280; /* Darker border color */
        }

        .timeline-line {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 4px; /* Thicker line */
            background-color: #cbd5e1;
            height: 100%;
            border-radius: 9999px;
            z-index: 0; /* Ensures line is behind cards */
        }

        /* Custom scrollbar for event list */
        .event-list::-webkit-scrollbar {
            width: 8px;
        }

        .event-list::-webkit-scrollbar-thumb {
            background-color: #94a3b8;
            border-radius: 4px;
        }

        .event-list::-webkit-scrollbar-track {
            background-color: #e2e8f0;
        }

        /* Mobile adjustments for timeline */
        @media (max-width: 767px) {
            .timeline-slot {
                min-height: 50px; /* Ensure slots are tall enough on mobile */
            }
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">

    <div class="container-flashback bg-white p-8 rounded-2xl shadow-2xl w-full">
        <!-- Game Title -->
        <h1 class="text-3xl font-extrabold text-center text-gray-800 mb-2">Flashback: Custom Edition</h1>
        <p class="text-center text-gray-500 mb-8">Place the historical events in chronological order.</p>
        
        <div class="flex flex-col md:flex-row gap-8">
            <!-- Event Cards Section -->
            <div class="md:w-1/2 p-4 bg-gray-50 rounded-xl shadow-inner">
                <h2 class="text-xl font-bold text-gray-700 mb-4">Events</h2>
                <div id="event-list" class="event-list flex flex-col gap-4 overflow-y-auto max-h-[50vh] md:max-h-full">
                    <!-- Event cards will be generated here by JavaScript -->
                </div>
            </div>

            <!-- Timeline Section -->
            <div class="md:w-1/2 p-4 bg-gray-50 rounded-xl shadow-inner flex flex-col items-center relative">
                <div id="timeline-line" class="timeline-line"></div>
                <h2 class="text-xl font-bold text-gray-700 mb-4 z-10">Timeline</h2>
                <div id="timeline" class="flex flex-col items-center w-full z-10">
                    <!-- Timeline slots and events will be generated here -->
                </div>
                <div id="win-message" class="hidden text-center mt-6 p-4 rounded-xl text-white font-bold text-lg bg-green-500 shadow-lg">
                    You've completed the timeline! Great job!
                </div>
                <div class="flex flex-col sm:flex-row gap-4 mt-8">
                    <button id="reset-button" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-6 rounded-full shadow-lg transition-all duration-300 transform hover:scale-105">
                        Start New Game
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Use a self-invoking function to avoid global variable pollution.
        (function() {
            // Game data: an array of objects with event and year.
            // Add your own custom events and dates here to change the game.
            // The years are approximate for chronological ordering.
            const gameEvents = [
                { id: 'e1', event: 'The birth of נביא שמואל to חנה', year: -1070 },
                { id: 'e2', event: 'שמואל becomes a נביא', year: -1060 },
                { id: 'e3', event: 'The capture of the Ark of the Covenant by the Philistines', year: -1050 },
                { id: 'e4', event: 'The Ark of the Covenant returns to Israel', year: -1049 },
                { id: 'e5', event: 'שאול is crowned king of Israel', year: -1030 },
                { id: 'e6', event: 'King שאול rebels against שמואל', year: -1025 },
                { id: 'e7', event: 'דוד is anointed by שמואל in בית לחם', year: -1015 },
                { id: 'e8', event: 'דוד slays גלית', year: -1014 },
                { id: 'e9', event: 'דוד flees from King שאול', year: -1012 },
                { id: 'e10', event: 'The death of שאול and his sons in battle', year: -1010 },
                { id: 'e11', event: 'שאול kills נוב עיר הכהנים', year: -1011 },
                { id: 'e12', event: 'שאול talking to בעלת אוב', year: -1010.5 }
            ];

            // DOM elements
            const eventList = document.getElementById('event-list');
            const timeline = document.getElementById('timeline');
            const resetButton = document.getElementById('reset-button');
            const winMessage = document.getElementById('win-message');
            
            // State variables
            let eventsInPlay = [];
            let timelineEvents = [];

            // Helper function to create a single event card element.
            const createEventCard = (eventObj) => {
                const card = document.createElement('div');
                card.id = `event-${eventObj.id}`;
                card.classList.add('event-card', 'bg-white', 'p-4', 'rounded-xl', 'shadow-md', 'border', 'border-gray-200', 'hover:bg-gray-50');
                card.textContent = eventObj.event;
                card.setAttribute('draggable', true);
                card.dataset.id = eventObj.id;
                return card;
            };

            // Helper function to create a timeline slot.
            const createTimelineSlot = () => {
                const slot = document.createElement('div');
                slot.classList.add('timeline-slot', 'w-full', 'min-h-[50px]', 'my-1', 'bg-gray-200', 'rounded-lg', 'border-dashed', 'border-2', 'border-gray-300');
                return slot;
            };

            // Initializes the game state.
            const initializeGame = () => {
                // Clear existing elements
                eventList.innerHTML = '';
                timeline.innerHTML = '';
                winMessage.classList.add('hidden');
                
                // Shuffle the game events to randomize the order.
                const shuffledEvents = [...gameEvents].sort(() => 0.5 - Math.random());
                eventsInPlay = shuffledEvents;
                timelineEvents = [];

                // Render the initial event cards in the list.
                eventsInPlay.forEach(event => {
                    eventList.appendChild(createEventCard(event));
                });

                // Render an initial empty slot on the timeline.
                timeline.appendChild(createTimelineSlot());
            };

            // Handles drag start event.
            const handleDragStart = (e) => {
                e.target.classList.add('dragging');
                e.dataTransfer.setData('text/plain', e.target.dataset.id);
            };

            // Handles drag end event.
            const handleDragEnd = (e) => {
                e.target.classList.remove('dragging');
            };
            
            // Handles drag over event. Prevents default to allow dropping.
            const handleDragOver = (e) => {
                e.preventDefault();
                const dropTarget = e.target.closest('.timeline-slot');
                if (dropTarget) {
                    dropTarget.classList.add('dragover');
                }
            };

            // Handles drag leave event.
            const handleDragLeave = (e) => {
                const dropTarget = e.target.closest('.timeline-slot');
                if (dropTarget) {
                    dropTarget.classList.remove('dragover');
                }
            };

            // Handles the drop event. Core game logic.
            const handleDrop = (e) => {
                e.preventDefault();
                const droppedId = e.dataTransfer.getData('text/plain');
                const droppedEvent = eventsInPlay.find(event => event.id === droppedId);
                const dropTarget = e.target.closest('.timeline-slot');

                if (!droppedEvent || !dropTarget) {
                    return;
                }

                dropTarget.classList.remove('dragover');

                // Get the index of the drop target slot.
                const allSlots = Array.from(timeline.querySelectorAll('.timeline-slot'));
                const dropIndex = allSlots.indexOf(dropTarget);

                // Find the events that would be before and after the dropped event.
                const beforeEvent = timelineEvents[dropIndex - 1];
                const afterEvent = timelineEvents[dropIndex];
                
                // Check if the placement is chronologically correct.
                // It must be after the beforeEvent (if it exists) and before the afterEvent (if it exists).
                const isAfterBefore = !beforeEvent || droppedEvent.year > beforeEvent.year;
                const isBeforeAfter = !afterEvent || droppedEvent.year < afterEvent.year;

                if (isAfterBefore && isBeforeAfter) {
                    // Correct placement
                    timelineEvents.splice(dropIndex, 0, droppedEvent);
                    eventsInPlay = eventsInPlay.filter(event => event.id !== droppedId);
                    
                    // Remove the dropped card from the event list
                    const cardToRemove = document.getElementById(`event-${droppedId}`);
                    if (cardToRemove) {
                        cardToRemove.remove();
                    }

                    // Update the timeline UI
                    updateTimelineUI();

                    // Check for win condition
                    if (eventsInPlay.length === 0) {
                        winMessage.classList.remove('hidden');
                    }
                } else {
                    // Incorrect placement, give visual feedback
                    dropTarget.classList.add('bg-red-300', 'border-red-500');
                    setTimeout(() => {
                        dropTarget.classList.remove('bg-red-300', 'border-red-500');
                    }, 500);
                }
            };

            // Updates the UI of the timeline with the current events.
            const updateTimelineUI = () => {
                timeline.innerHTML = ''; // Clear timeline
                
                // Sort events by year before rendering.
                timelineEvents.sort((a, b) => a.year - b.year);

                // Create a slot before all events.
                if (timelineEvents.length < gameEvents.length) {
                    timeline.appendChild(createTimelineSlot());
                }

                // Render events and slots.
                timelineEvents.forEach(event => {
                    const eventCard = createEventCard(event);
                    eventCard.classList.add('event-on-timeline');
                    eventCard.setAttribute('draggable', false); // Can't be dragged again
                    eventCard.textContent = `${event.event}`;
                    eventCard.classList.remove('bg-white', 'hover:bg-gray-50');
                    eventCard.classList.add('bg-indigo-200', 'font-semibold', 'text-indigo-800', 'border-indigo-400', 'mb-2');
                    timeline.appendChild(eventCard);
                    
                    if (eventsInPlay.length > 0) {
                         timeline.appendChild(createTimelineSlot());
                    }
                });
            };

            const copyCode = () => {
                const codeToCopy = document.querySelector('code').textContent;
                const tempTextarea = document.createElement('textarea');
                tempTextarea.value = codeToCopy;
                document.body.appendChild(tempTextarea);
                tempTextarea.select();
                document.execCommand('copy');
                document.body.removeChild(tempTextarea);
                alert('Code copied to clipboard!');
            };
            
            // Main event listeners
            document.addEventListener('dragstart', handleDragStart);
            document.addEventListener('dragend', handleDragEnd);
            document.addEventListener('dragover', handleDragOver);
            document.addEventListener('dragleave', handleDragLeave);
            document.addEventListener('drop', handleDrop);
            
            // Reset and Copy button listeners
            resetButton.addEventListener('click', initializeGame);

            // Initial game setup
            initializeGame();

        })();
    </script>
</body>
</html>
